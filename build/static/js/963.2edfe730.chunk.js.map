{"version":3,"file":"static/js/963.2edfe730.chunk.js","mappings":"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","sources":["../node_modules/recharts/es6/state/selectors/areaSelectors.js","../node_modules/recharts/es6/cartesian/Area.js"],"sourcesContent":["import { createSelector } from 'reselect';\nimport { computeArea } from '../../cartesian/Area';\nimport { selectAxisWithScale, selectStackGroups, selectTicksOfGraphicalItem, selectUnfilteredCartesianItems } from './axisSelectors';\nimport { selectChartLayout } from '../../context/chartLayoutContext';\nimport { selectChartDataWithIndexesIfNotInPanorama } from './dataSelectors';\nimport { getBandSizeOfAxis, getNormalizedStackId, isCategoricalAxis } from '../../util/ChartUtils';\nvar selectXAxisWithScale = (state, xAxisId, _yAxisId, isPanorama) => selectAxisWithScale(state, 'xAxis', xAxisId, isPanorama);\nvar selectXAxisTicks = (state, xAxisId, _yAxisId, isPanorama) => selectTicksOfGraphicalItem(state, 'xAxis', xAxisId, isPanorama);\nvar selectYAxisWithScale = (state, _xAxisId, yAxisId, isPanorama) => selectAxisWithScale(state, 'yAxis', yAxisId, isPanorama);\nvar selectYAxisTicks = (state, _xAxisId, yAxisId, isPanorama) => selectTicksOfGraphicalItem(state, 'yAxis', yAxisId, isPanorama);\nvar selectBandSize = createSelector([selectChartLayout, selectXAxisWithScale, selectYAxisWithScale, selectXAxisTicks, selectYAxisTicks], (layout, xAxis, yAxis, xAxisTicks, yAxisTicks) => {\n  if (isCategoricalAxis(layout, 'xAxis')) {\n    return getBandSizeOfAxis(xAxis, xAxisTicks, false);\n  }\n  return getBandSizeOfAxis(yAxis, yAxisTicks, false);\n});\nvar selectGraphicalItemStackedData = (state, xAxisId, yAxisId, isPanorama, areaSettings) => {\n  var _stackGroups$stackId;\n  var layout = selectChartLayout(state);\n  var isXAxisCategorical = isCategoricalAxis(layout, 'xAxis');\n  var stackGroups;\n  if (isXAxisCategorical) {\n    stackGroups = selectStackGroups(state, 'yAxis', yAxisId, isPanorama);\n  } else {\n    stackGroups = selectStackGroups(state, 'xAxis', xAxisId, isPanorama);\n  }\n  if (stackGroups == null) {\n    return undefined;\n  }\n  var {\n    dataKey,\n    stackId\n  } = areaSettings;\n  if (stackId == null) {\n    return undefined;\n  }\n  var groups = (_stackGroups$stackId = stackGroups[stackId]) === null || _stackGroups$stackId === void 0 ? void 0 : _stackGroups$stackId.stackedData;\n  return groups === null || groups === void 0 ? void 0 : groups.find(v => v.key === dataKey);\n};\nvar pickAreaSettings = (_state, _xAxisId, _yAxisId, _isPanorama, areaSettings) => areaSettings;\n\n/*\n * There is a race condition problem because we read some data from props and some from the state.\n * The state is updated through a dispatch and is one render behind,\n * and so we have this weird one tick render where the displayedData in one selector have the old dataKey\n * but the new dataKey in another selector.\n *\n * A proper fix is to either move everything into the state, or read the dataKey always from props\n * - but this is a smaller change.\n */\nvar selectSynchronisedAreaSettings = createSelector([selectUnfilteredCartesianItems, pickAreaSettings], (graphicalItems, areaSettingsFromProps) => {\n  if (graphicalItems.some(cgis => cgis.type === 'area' && areaSettingsFromProps.dataKey === cgis.dataKey && getNormalizedStackId(areaSettingsFromProps.stackId) === cgis.stackId && areaSettingsFromProps.data === cgis.data)) {\n    /*\n     * now, at least one of the areas has the same dataKey as the one in props.\n     * Is this a perfect match? Maybe not because we could theoretically have two different Areas with the same dataKey\n     * and the same stackId and the same data but still different areas, yes,\n     * but the chances of that happening are ... lowish.\n     *\n     * A proper fix would be to store the areaSettings in a state too, and compare references directly instead of enumerating the properties.\n     */\n    return areaSettingsFromProps;\n  }\n  return undefined;\n});\nexport var selectArea = createSelector([selectChartLayout, selectXAxisWithScale, selectYAxisWithScale, selectXAxisTicks, selectYAxisTicks, selectGraphicalItemStackedData, selectChartDataWithIndexesIfNotInPanorama, selectBandSize, selectSynchronisedAreaSettings], (layout, xAxis, yAxis, xAxisTicks, yAxisTicks, stackedData, _ref, bandSize, areaSettings) => {\n  var {\n    chartData,\n    dataStartIndex,\n    dataEndIndex\n  } = _ref;\n  if (areaSettings == null || layout !== 'horizontal' && layout !== 'vertical' || xAxis == null || yAxis == null || xAxisTicks == null || yAxisTicks == null || xAxisTicks.length === 0 || yAxisTicks.length === 0 || bandSize == null) {\n    return undefined;\n  }\n  var {\n    data\n  } = areaSettings;\n  var displayedData;\n  if (data && data.length > 0) {\n    displayedData = data;\n  } else {\n    displayedData = chartData === null || chartData === void 0 ? void 0 : chartData.slice(dataStartIndex, dataEndIndex + 1);\n  }\n  if (displayedData == null) {\n    return undefined;\n  }\n\n  // Where is this supposed to come from? No charts have that as a prop.\n  var chartBaseValue = undefined;\n  return computeArea({\n    layout,\n    xAxis,\n    yAxis,\n    xAxisTicks,\n    yAxisTicks,\n    dataStartIndex,\n    areaSettings,\n    stackedData,\n    displayedData,\n    chartBaseValue,\n    bandSize\n  });\n});","var _excluded = [\"layout\", \"type\", \"stroke\", \"connectNulls\", \"isRange\"],\n  _excluded2 = [\"activeDot\", \"animationBegin\", \"animationDuration\", \"animationEasing\", \"connectNulls\", \"dot\", \"fill\", \"fillOpacity\", \"hide\", \"isAnimationActive\", \"legendType\", \"stroke\", \"xAxisId\", \"yAxisId\"];\nfunction _objectWithoutProperties(e, t) { if (null == e) return {}; var o, r, i = _objectWithoutPropertiesLoose(e, t); if (Object.getOwnPropertySymbols) { var n = Object.getOwnPropertySymbols(e); for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]); } return i; }\nfunction _objectWithoutPropertiesLoose(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (-1 !== e.indexOf(n)) continue; t[n] = r[n]; } return t; }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _extends() { return _extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, _extends.apply(null, arguments); }\n// eslint-disable-next-line max-classes-per-file\nimport * as React from 'react';\nimport { PureComponent, useCallback, useMemo, useRef, useState } from 'react';\nimport { clsx } from 'clsx';\nimport { Curve } from '../shape/Curve';\nimport { Dot } from '../shape/Dot';\nimport { Layer } from '../container/Layer';\nimport { LabelList } from '../component/LabelList';\nimport { Global } from '../util/Global';\nimport { interpolate, isNan, isNullish, isNumber, uniqueId } from '../util/DataUtils';\nimport { getCateCoordinateOfLine, getTooltipNameProp, getValueByDataKey } from '../util/ChartUtils';\nimport { filterProps, isClipDot } from '../util/ReactUtils';\nimport { ActivePoints } from '../component/ActivePoints';\nimport { SetTooltipEntrySettings } from '../state/SetTooltipEntrySettings';\nimport { CartesianGraphicalItemContext } from '../context/CartesianGraphicalItemContext';\nimport { GraphicalItemClipPath, useNeedsClip } from './GraphicalItemClipPath';\nimport { selectArea } from '../state/selectors/areaSelectors';\nimport { useIsPanorama } from '../context/PanoramaContext';\nimport { useChartLayout, useOffset } from '../context/chartLayoutContext';\nimport { useChartName } from '../state/selectors/selectors';\nimport { SetLegendPayload } from '../state/SetLegendPayload';\nimport { useAppSelector } from '../state/hooks';\nimport { useAnimationId } from '../util/useAnimationId';\nimport { resolveDefaultProps } from '../util/resolveDefaultProps';\nimport { isWellBehavedNumber } from '../util/isWellBehavedNumber';\nimport { Animate } from '../animation/Animate';\n\n/**\n * Internal props, combination of external props + defaultProps + private Recharts state\n */\n\n/**\n * External props, intended for end users to fill in\n */\n\n/**\n * Because of naming conflict, we are forced to ignore certain (valid) SVG attributes.\n */\n\nfunction getLegendItemColor(stroke, fill) {\n  return stroke && stroke !== 'none' ? stroke : fill;\n}\nvar computeLegendPayloadFromAreaData = props => {\n  var {\n    dataKey,\n    name,\n    stroke,\n    fill,\n    legendType,\n    hide\n  } = props;\n  return [{\n    inactive: hide,\n    dataKey,\n    type: legendType,\n    color: getLegendItemColor(stroke, fill),\n    value: getTooltipNameProp(name, dataKey),\n    payload: props\n  }];\n};\nfunction getTooltipEntrySettings(props) {\n  var {\n    dataKey,\n    data,\n    stroke,\n    strokeWidth,\n    fill,\n    name,\n    hide,\n    unit\n  } = props;\n  return {\n    dataDefinedOnItem: data,\n    positions: undefined,\n    settings: {\n      stroke,\n      strokeWidth,\n      fill,\n      dataKey,\n      nameKey: undefined,\n      name: getTooltipNameProp(name, dataKey),\n      hide,\n      type: props.tooltipType,\n      color: getLegendItemColor(stroke, fill),\n      unit\n    }\n  };\n}\nvar renderDotItem = (option, props) => {\n  var dotItem;\n  if (/*#__PURE__*/React.isValidElement(option)) {\n    dotItem = /*#__PURE__*/React.cloneElement(option, props);\n  } else if (typeof option === 'function') {\n    dotItem = option(props);\n  } else {\n    var className = clsx('recharts-area-dot', typeof option !== 'boolean' ? option.className : '');\n    dotItem = /*#__PURE__*/React.createElement(Dot, _extends({}, props, {\n      className: className\n    }));\n  }\n  return dotItem;\n};\nfunction shouldRenderDots(points, dot) {\n  if (points == null) {\n    return false;\n  }\n  if (dot) {\n    return true;\n  }\n  return points.length === 1;\n}\nfunction Dots(_ref) {\n  var {\n    clipPathId,\n    points,\n    props\n  } = _ref;\n  var {\n    needClip,\n    dot,\n    dataKey\n  } = props;\n  if (!shouldRenderDots(points, dot)) {\n    return null;\n  }\n  var clipDot = isClipDot(dot);\n  var areaProps = filterProps(props, false);\n  var customDotProps = filterProps(dot, true);\n  var dots = points.map((entry, i) => {\n    var dotProps = _objectSpread(_objectSpread(_objectSpread({\n      key: \"dot-\".concat(i),\n      r: 3\n    }, areaProps), customDotProps), {}, {\n      index: i,\n      cx: entry.x,\n      cy: entry.y,\n      dataKey,\n      value: entry.value,\n      payload: entry.payload,\n      points\n    });\n    return renderDotItem(dot, dotProps);\n  });\n  var dotsProps = {\n    clipPath: needClip ? \"url(#clipPath-\".concat(clipDot ? '' : 'dots-').concat(clipPathId, \")\") : undefined\n  };\n  return /*#__PURE__*/React.createElement(Layer, _extends({\n    className: \"recharts-area-dots\"\n  }, dotsProps), dots);\n}\nfunction StaticArea(_ref2) {\n  var {\n    points,\n    baseLine,\n    needClip,\n    clipPathId,\n    props,\n    showLabels\n  } = _ref2;\n  var {\n      layout,\n      type,\n      stroke,\n      connectNulls,\n      isRange\n    } = props,\n    others = _objectWithoutProperties(props, _excluded);\n  return /*#__PURE__*/React.createElement(React.Fragment, null, (points === null || points === void 0 ? void 0 : points.length) > 1 && /*#__PURE__*/React.createElement(Layer, {\n    clipPath: needClip ? \"url(#clipPath-\".concat(clipPathId, \")\") : undefined\n  }, /*#__PURE__*/React.createElement(Curve, _extends({}, filterProps(others, true), {\n    points: points,\n    connectNulls: connectNulls,\n    type: type,\n    baseLine: baseLine,\n    layout: layout,\n    stroke: \"none\",\n    className: \"recharts-area-area\"\n  })), stroke !== 'none' && /*#__PURE__*/React.createElement(Curve, _extends({}, filterProps(props, false), {\n    className: \"recharts-area-curve\",\n    layout: layout,\n    type: type,\n    connectNulls: connectNulls,\n    fill: \"none\",\n    points: points\n  })), stroke !== 'none' && isRange && /*#__PURE__*/React.createElement(Curve, _extends({}, filterProps(props, false), {\n    className: \"recharts-area-curve\",\n    layout: layout,\n    type: type,\n    connectNulls: connectNulls,\n    fill: \"none\",\n    points: baseLine\n  }))), /*#__PURE__*/React.createElement(Dots, {\n    points: points,\n    props: props,\n    clipPathId: clipPathId\n  }), showLabels && LabelList.renderCallByParent(props, points));\n}\nfunction VerticalRect(_ref3) {\n  var {\n    alpha,\n    baseLine,\n    points,\n    strokeWidth\n  } = _ref3;\n  var startY = points[0].y;\n  var endY = points[points.length - 1].y;\n  if (!isWellBehavedNumber(startY) || !isWellBehavedNumber(endY)) {\n    return null;\n  }\n  var height = alpha * Math.abs(startY - endY);\n  var maxX = Math.max(...points.map(entry => entry.x || 0));\n  if (isNumber(baseLine)) {\n    maxX = Math.max(baseLine, maxX);\n  } else if (baseLine && Array.isArray(baseLine) && baseLine.length) {\n    maxX = Math.max(...baseLine.map(entry => entry.x || 0), maxX);\n  }\n  if (isNumber(maxX)) {\n    return /*#__PURE__*/React.createElement(\"rect\", {\n      x: 0,\n      y: startY < endY ? startY : startY - height,\n      width: maxX + (strokeWidth ? parseInt(\"\".concat(strokeWidth), 10) : 1),\n      height: Math.floor(height)\n    });\n  }\n  return null;\n}\nfunction HorizontalRect(_ref4) {\n  var {\n    alpha,\n    baseLine,\n    points,\n    strokeWidth\n  } = _ref4;\n  var startX = points[0].x;\n  var endX = points[points.length - 1].x;\n  if (!isWellBehavedNumber(startX) || !isWellBehavedNumber(endX)) {\n    return null;\n  }\n  var width = alpha * Math.abs(startX - endX);\n  var maxY = Math.max(...points.map(entry => entry.y || 0));\n  if (isNumber(baseLine)) {\n    maxY = Math.max(baseLine, maxY);\n  } else if (baseLine && Array.isArray(baseLine) && baseLine.length) {\n    maxY = Math.max(...baseLine.map(entry => entry.y || 0), maxY);\n  }\n  if (isNumber(maxY)) {\n    return /*#__PURE__*/React.createElement(\"rect\", {\n      x: startX < endX ? startX : startX - width,\n      y: 0,\n      width: width,\n      height: Math.floor(maxY + (strokeWidth ? parseInt(\"\".concat(strokeWidth), 10) : 1))\n    });\n  }\n  return null;\n}\nfunction ClipRect(_ref5) {\n  var {\n    alpha,\n    layout,\n    points,\n    baseLine,\n    strokeWidth\n  } = _ref5;\n  if (layout === 'vertical') {\n    return /*#__PURE__*/React.createElement(VerticalRect, {\n      alpha: alpha,\n      points: points,\n      baseLine: baseLine,\n      strokeWidth: strokeWidth\n    });\n  }\n  return /*#__PURE__*/React.createElement(HorizontalRect, {\n    alpha: alpha,\n    points: points,\n    baseLine: baseLine,\n    strokeWidth: strokeWidth\n  });\n}\nfunction AreaWithAnimation(_ref6) {\n  var {\n    needClip,\n    clipPathId,\n    props,\n    previousPointsRef,\n    previousBaselineRef\n  } = _ref6;\n  var {\n    points,\n    baseLine,\n    isAnimationActive,\n    animationBegin,\n    animationDuration,\n    animationEasing,\n    onAnimationStart,\n    onAnimationEnd\n  } = props;\n  var animationId = useAnimationId(props, 'recharts-area-');\n  var [isAnimating, setIsAnimating] = useState(true);\n  var handleAnimationEnd = useCallback(() => {\n    if (typeof onAnimationEnd === 'function') {\n      onAnimationEnd();\n    }\n    setIsAnimating(false);\n  }, [onAnimationEnd]);\n  var handleAnimationStart = useCallback(() => {\n    if (typeof onAnimationStart === 'function') {\n      onAnimationStart();\n    }\n    setIsAnimating(true);\n  }, [onAnimationStart]);\n  var prevPoints = previousPointsRef.current;\n  var prevBaseLine = previousBaselineRef.current;\n  return /*#__PURE__*/React.createElement(Animate, {\n    begin: animationBegin,\n    duration: animationDuration,\n    isActive: isAnimationActive,\n    easing: animationEasing,\n    from: {\n      t: 0\n    },\n    to: {\n      t: 1\n    },\n    onAnimationEnd: handleAnimationEnd,\n    onAnimationStart: handleAnimationStart,\n    key: animationId\n  }, _ref7 => {\n    var {\n      t\n    } = _ref7;\n    if (prevPoints) {\n      var prevPointsDiffFactor = prevPoints.length / points.length;\n      var stepPoints =\n      /*\n       * Here it is important that at the very end of the animation, on the last frame,\n       * we render the original points without any interpolation.\n       * This is needed because the code above is checking for reference equality to decide if the animation should run\n       * and if we create a new array instance (even if the numbers were the same)\n       * then we would break animations.\n       */\n      t === 1 ? points : points.map((entry, index) => {\n        var prevPointIndex = Math.floor(index * prevPointsDiffFactor);\n        if (prevPoints[prevPointIndex]) {\n          var prev = prevPoints[prevPointIndex];\n          return _objectSpread(_objectSpread({}, entry), {}, {\n            x: interpolate(prev.x, entry.x, t),\n            y: interpolate(prev.y, entry.y, t)\n          });\n        }\n        return entry;\n      });\n      var stepBaseLine;\n      if (isNumber(baseLine)) {\n        stepBaseLine = interpolate(prevBaseLine, baseLine, t);\n      } else if (isNullish(baseLine) || isNan(baseLine)) {\n        stepBaseLine = interpolate(prevBaseLine, 0, t);\n      } else {\n        stepBaseLine = baseLine.map((entry, index) => {\n          var prevPointIndex = Math.floor(index * prevPointsDiffFactor);\n          if (Array.isArray(prevBaseLine) && prevBaseLine[prevPointIndex]) {\n            var prev = prevBaseLine[prevPointIndex];\n            return _objectSpread(_objectSpread({}, entry), {}, {\n              x: interpolate(prev.x, entry.x, t),\n              y: interpolate(prev.y, entry.y, t)\n            });\n          }\n          return entry;\n        });\n      }\n      if (t > 0) {\n        /*\n         * We need to keep the refs in the parent component because we need to remember the last shape of the animation\n         * even if AreaWithAnimation is unmounted as that happens when changing props.\n         *\n         * And we need to update the refs here because here is where the interpolation is computed.\n         * Eslint doesn't like changing function arguments, but we need it so here is an eslint-disable.\n         */\n        // eslint-disable-next-line no-param-reassign\n        previousPointsRef.current = stepPoints;\n        // eslint-disable-next-line no-param-reassign\n        previousBaselineRef.current = stepBaseLine;\n      }\n      return /*#__PURE__*/React.createElement(StaticArea, {\n        points: stepPoints,\n        baseLine: stepBaseLine,\n        needClip: needClip,\n        clipPathId: clipPathId,\n        props: props,\n        showLabels: !isAnimating\n      });\n    }\n    if (t > 0) {\n      // eslint-disable-next-line no-param-reassign\n      previousPointsRef.current = points;\n      // eslint-disable-next-line no-param-reassign\n      previousBaselineRef.current = baseLine;\n    }\n    return /*#__PURE__*/React.createElement(Layer, null, /*#__PURE__*/React.createElement(\"defs\", null, /*#__PURE__*/React.createElement(\"clipPath\", {\n      id: \"animationClipPath-\".concat(clipPathId)\n    }, /*#__PURE__*/React.createElement(ClipRect, {\n      alpha: t,\n      points: points,\n      baseLine: baseLine,\n      layout: props.layout,\n      strokeWidth: props.strokeWidth\n    }))), /*#__PURE__*/React.createElement(Layer, {\n      clipPath: \"url(#animationClipPath-\".concat(clipPathId, \")\")\n    }, /*#__PURE__*/React.createElement(StaticArea, {\n      points: points,\n      baseLine: baseLine,\n      needClip: needClip,\n      clipPathId: clipPathId,\n      props: props,\n      showLabels: true\n    })));\n  });\n}\n\n/*\n * This components decides if the area should be animated or not.\n * It also holds the state of the animation.\n */\nfunction RenderArea(_ref8) {\n  var {\n    needClip,\n    clipPathId,\n    props\n  } = _ref8;\n  var {\n    points,\n    baseLine,\n    isAnimationActive\n  } = props;\n\n  /*\n   * These two must be refs, not state!\n   * Because we want to store the most recent shape of the animation in case we have to interrupt the animation;\n   * that happens when user initiates another animation before the current one finishes.\n   *\n   * If this was a useState, then every step in the animation would trigger a re-render.\n   * So, useRef it is.\n   */\n  var previousPointsRef = useRef(null);\n  var previousBaselineRef = useRef();\n  var prevPoints = previousPointsRef.current;\n  var prevBaseLine = previousBaselineRef.current;\n  if (isAnimationActive &&\n  /*\n   * Here it's important that we unmount of AreaWithAnimation in case points are undefined\n   * - this will make sure to interrupt the animation if it's running.\n   * We still get to keep the last shape of the animation in the refs above.\n   */\n  points && points.length && (prevPoints !== points || prevBaseLine !== baseLine)) {\n    return /*#__PURE__*/React.createElement(AreaWithAnimation, {\n      needClip: needClip,\n      clipPathId: clipPathId,\n      props: props,\n      previousPointsRef: previousPointsRef,\n      previousBaselineRef: previousBaselineRef\n    });\n  }\n  return /*#__PURE__*/React.createElement(StaticArea, {\n    points: points,\n    baseLine: baseLine,\n    needClip: needClip,\n    clipPathId: clipPathId,\n    props: props,\n    showLabels: true\n  });\n}\nclass AreaWithState extends PureComponent {\n  constructor() {\n    super(...arguments);\n    _defineProperty(this, \"id\", uniqueId('recharts-area-'));\n  }\n  render() {\n    var _filterProps;\n    var {\n      hide,\n      dot,\n      points,\n      className,\n      top,\n      left,\n      needClip,\n      xAxisId,\n      yAxisId,\n      width,\n      height,\n      id,\n      baseLine\n    } = this.props;\n    if (hide) {\n      return null;\n    }\n    var layerClass = clsx('recharts-area', className);\n    var clipPathId = isNullish(id) ? this.id : id;\n    var {\n      r = 3,\n      strokeWidth = 2\n    } = (_filterProps = filterProps(dot, false)) !== null && _filterProps !== void 0 ? _filterProps : {\n      r: 3,\n      strokeWidth: 2\n    };\n    var clipDot = isClipDot(dot);\n    var dotSize = r * 2 + strokeWidth;\n    return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(Layer, {\n      className: layerClass\n    }, needClip && /*#__PURE__*/React.createElement(\"defs\", null, /*#__PURE__*/React.createElement(GraphicalItemClipPath, {\n      clipPathId: clipPathId,\n      xAxisId: xAxisId,\n      yAxisId: yAxisId\n    }), !clipDot && /*#__PURE__*/React.createElement(\"clipPath\", {\n      id: \"clipPath-dots-\".concat(clipPathId)\n    }, /*#__PURE__*/React.createElement(\"rect\", {\n      x: left - dotSize / 2,\n      y: top - dotSize / 2,\n      width: width + dotSize,\n      height: height + dotSize\n    }))), /*#__PURE__*/React.createElement(RenderArea, {\n      needClip: needClip,\n      clipPathId: clipPathId,\n      props: this.props\n    })), /*#__PURE__*/React.createElement(ActivePoints, {\n      points: points,\n      mainColor: getLegendItemColor(this.props.stroke, this.props.fill),\n      itemDataKey: this.props.dataKey,\n      activeDot: this.props.activeDot\n    }), this.props.isRange && Array.isArray(baseLine) && /*#__PURE__*/React.createElement(ActivePoints, {\n      points: baseLine,\n      mainColor: getLegendItemColor(this.props.stroke, this.props.fill),\n      itemDataKey: this.props.dataKey,\n      activeDot: this.props.activeDot\n    }));\n  }\n}\nvar defaultAreaProps = {\n  activeDot: true,\n  animationBegin: 0,\n  animationDuration: 1500,\n  animationEasing: 'ease',\n  connectNulls: false,\n  dot: false,\n  fill: '#3182bd',\n  fillOpacity: 0.6,\n  hide: false,\n  isAnimationActive: !Global.isSsr,\n  legendType: 'line',\n  stroke: '#3182bd',\n  xAxisId: 0,\n  yAxisId: 0\n};\nfunction AreaImpl(props) {\n  var _useAppSelector;\n  var _resolveDefaultProps = resolveDefaultProps(props, defaultAreaProps),\n    {\n      activeDot,\n      animationBegin,\n      animationDuration,\n      animationEasing,\n      connectNulls,\n      dot,\n      fill,\n      fillOpacity,\n      hide,\n      isAnimationActive,\n      legendType,\n      stroke,\n      xAxisId,\n      yAxisId\n    } = _resolveDefaultProps,\n    everythingElse = _objectWithoutProperties(_resolveDefaultProps, _excluded2);\n  var layout = useChartLayout();\n  var chartName = useChartName();\n  var {\n    needClip\n  } = useNeedsClip(xAxisId, yAxisId);\n  var isPanorama = useIsPanorama();\n  var areaSettings = useMemo(() => ({\n    baseValue: props.baseValue,\n    stackId: props.stackId,\n    connectNulls,\n    data: props.data,\n    dataKey: props.dataKey\n  }), [props.baseValue, props.stackId, connectNulls, props.data, props.dataKey]);\n  var {\n    points,\n    isRange,\n    baseLine\n  } = (_useAppSelector = useAppSelector(state => selectArea(state, xAxisId, yAxisId, isPanorama, areaSettings))) !== null && _useAppSelector !== void 0 ? _useAppSelector : {};\n  var {\n    height,\n    width,\n    left,\n    top\n  } = useOffset();\n  if (layout !== 'horizontal' && layout !== 'vertical') {\n    // Can't render Area in an unsupported layout\n    return null;\n  }\n  if (chartName !== 'AreaChart' && chartName !== 'ComposedChart') {\n    // There is nothing stopping us from rendering Area in other charts, except for historical reasons. Do we want to allow that?\n    return null;\n  }\n\n  /*\n   * It is important to NOT have this condition here,\n   * because we need the Animate inside to receive an empty state\n   * so that it can properly reset its internal state and start a new animation.\n   */\n  // if (!points || !points.length) {\n  //   return null;\n  // }\n\n  return /*#__PURE__*/React.createElement(AreaWithState, _extends({}, everythingElse, {\n    activeDot: activeDot,\n    animationBegin: animationBegin,\n    animationDuration: animationDuration,\n    animationEasing: animationEasing,\n    baseLine: baseLine,\n    connectNulls: connectNulls,\n    dot: dot,\n    fill: fill,\n    fillOpacity: fillOpacity,\n    height: height,\n    hide: hide,\n    layout: layout,\n    isAnimationActive: isAnimationActive,\n    isRange: isRange,\n    legendType: legendType,\n    needClip: needClip,\n    points: points,\n    stroke: stroke,\n    width: width,\n    left: left,\n    top: top,\n    xAxisId: xAxisId,\n    yAxisId: yAxisId\n  }));\n}\nexport var getBaseValue = (layout, chartBaseValue, itemBaseValue, xAxis, yAxis) => {\n  // The baseValue can be defined both on the AreaChart, and on the Area.\n  // The value for the item takes precedence.\n  var baseValue = itemBaseValue !== null && itemBaseValue !== void 0 ? itemBaseValue : chartBaseValue;\n  if (isNumber(baseValue)) {\n    return baseValue;\n  }\n  var numericAxis = layout === 'horizontal' ? yAxis : xAxis;\n  // @ts-expect-error d3scale .domain() returns unknown, Math.max expects number\n  var domain = numericAxis.scale.domain();\n  if (numericAxis.type === 'number') {\n    var domainMax = Math.max(domain[0], domain[1]);\n    var domainMin = Math.min(domain[0], domain[1]);\n    if (baseValue === 'dataMin') {\n      return domainMin;\n    }\n    if (baseValue === 'dataMax') {\n      return domainMax;\n    }\n    return domainMax < 0 ? domainMax : Math.max(Math.min(domain[0], domain[1]), 0);\n  }\n  if (baseValue === 'dataMin') {\n    return domain[0];\n  }\n  if (baseValue === 'dataMax') {\n    return domain[1];\n  }\n  return domain[0];\n};\nexport function computeArea(_ref9) {\n  var {\n    areaSettings: {\n      connectNulls,\n      baseValue: itemBaseValue,\n      dataKey\n    },\n    stackedData,\n    layout,\n    chartBaseValue,\n    xAxis,\n    yAxis,\n    displayedData,\n    dataStartIndex,\n    xAxisTicks,\n    yAxisTicks,\n    bandSize\n  } = _ref9;\n  var hasStack = stackedData && stackedData.length;\n  var baseValue = getBaseValue(layout, chartBaseValue, itemBaseValue, xAxis, yAxis);\n  var isHorizontalLayout = layout === 'horizontal';\n  var isRange = false;\n  var points = displayedData.map((entry, index) => {\n    var value;\n    if (hasStack) {\n      value = stackedData[dataStartIndex + index];\n    } else {\n      value = getValueByDataKey(entry, dataKey);\n      if (!Array.isArray(value)) {\n        value = [baseValue, value];\n      } else {\n        isRange = true;\n      }\n    }\n    var isBreakPoint = value[1] == null || hasStack && !connectNulls && getValueByDataKey(entry, dataKey) == null;\n    if (isHorizontalLayout) {\n      return {\n        // @ts-expect-error getCateCoordinateOfLine expects chart data to be an object, we allow unknown\n        x: getCateCoordinateOfLine({\n          axis: xAxis,\n          ticks: xAxisTicks,\n          bandSize,\n          entry,\n          index\n        }),\n        y: isBreakPoint ? null : yAxis.scale(value[1]),\n        value,\n        payload: entry\n      };\n    }\n    return {\n      x: isBreakPoint ? null : xAxis.scale(value[1]),\n      // @ts-expect-error getCateCoordinateOfLine expects chart data to be an object, we allow unknown\n      y: getCateCoordinateOfLine({\n        axis: yAxis,\n        ticks: yAxisTicks,\n        bandSize,\n        entry,\n        index\n      }),\n      value,\n      payload: entry\n    };\n  });\n  var baseLine;\n  if (hasStack || isRange) {\n    baseLine = points.map(entry => {\n      var x = Array.isArray(entry.value) ? entry.value[0] : null;\n      if (isHorizontalLayout) {\n        return {\n          x: entry.x,\n          y: x != null && entry.y != null ? yAxis.scale(x) : null\n        };\n      }\n      return {\n        x: x != null ? xAxis.scale(x) : null,\n        y: entry.y\n      };\n    });\n  } else {\n    baseLine = isHorizontalLayout ? yAxis.scale(baseValue) : xAxis.scale(baseValue);\n  }\n  return {\n    points,\n    baseLine,\n    isRange\n  };\n}\nexport class Area extends PureComponent {\n  render() {\n    // Report all props to Redux store first, before calling any hooks, to avoid circular dependencies.\n    return /*#__PURE__*/React.createElement(CartesianGraphicalItemContext, {\n      type: \"area\",\n      data: this.props.data,\n      dataKey: this.props.dataKey,\n      xAxisId: this.props.xAxisId,\n      yAxisId: this.props.yAxisId,\n      zAxisId: 0,\n      stackId: this.props.stackId,\n      hide: this.props.hide,\n      barSize: undefined\n    }, /*#__PURE__*/React.createElement(SetLegendPayload, {\n      legendPayload: computeLegendPayloadFromAreaData(this.props)\n    }), /*#__PURE__*/React.createElement(SetTooltipEntrySettings, {\n      fn: getTooltipEntrySettings,\n      args: this.props\n    }), /*#__PURE__*/React.createElement(AreaImpl, this.props));\n  }\n}\n_defineProperty(Area, \"displayName\", 'Area');\n_defineProperty(Area, \"defaultProps\", defaultAreaProps);"],"names":["selectXAxisWithScale","state","xAxisId","_yAxisId","isPanorama","selectAxisWithScale","selectXAxisTicks","selectTicksOfGraphicalItem","selectYAxisWithScale","_xAxisId","yAxisId","selectYAxisTicks","selectBandSize","createSelector","selectChartLayout","layout","xAxis","yAxis","xAxisTicks","yAxisTicks","isCategoricalAxis","getBandSizeOfAxis","selectSynchronisedAreaSettings","selectUnfilteredCartesianItems","pickAreaSettings","_state","_isPanorama","areaSettings","graphicalItems","areaSettingsFromProps","some","cgis","type","dataKey","getNormalizedStackId","stackId","data","selectArea","selectGraphicalItemStackedData","_stackGroups$stackId","stackGroups","selectStackGroups","groups","stackedData","find","v","key","selectChartDataWithIndexesIfNotInPanorama","_ref","bandSize","chartData","dataStartIndex","dataEndIndex","length","displayedData","slice","computeArea","chartBaseValue","undefined","_excluded","_excluded2","_objectWithoutProperties","e","t","o","r","i","n","hasOwnProperty","call","indexOf","_objectWithoutPropertiesLoose","Object","getOwnPropertySymbols","propertyIsEnumerable","ownKeys","keys","filter","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","arguments","forEach","_defineProperty","getOwnPropertyDescriptors","defineProperties","defineProperty","Symbol","toPrimitive","TypeError","String","Number","_toPrimitive","_toPropertyKey","value","configurable","writable","_extends","assign","bind","getLegendItemColor","stroke","fill","computeLegendPayloadFromAreaData","props","name","legendType","hide","inactive","color","getTooltipNameProp","payload","getTooltipEntrySettings","strokeWidth","unit","dataDefinedOnItem","positions","settings","nameKey","tooltipType","Dots","clipPathId","points","needClip","dot","shouldRenderDots","clipDot","isClipDot","areaProps","filterProps","customDotProps","dots","map","entry","dotProps","concat","index","cx","x","cy","y","renderDotItem","option","dotItem","React","className","clsx","Dot","dotsProps","clipPath","Layer","StaticArea","_ref2","baseLine","showLabels","connectNulls","isRange","others","Curve","LabelList","renderCallByParent","VerticalRect","_ref3","alpha","startY","endY","isWellBehavedNumber","height","Math","abs","maxX","max","isNumber","Array","isArray","width","parseInt","floor","HorizontalRect","_ref4","startX","endX","maxY","ClipRect","_ref5","AreaWithAnimation","_ref6","previousPointsRef","previousBaselineRef","isAnimationActive","animationBegin","animationDuration","animationEasing","onAnimationStart","onAnimationEnd","animationId","useAnimationId","isAnimating","setIsAnimating","useState","handleAnimationEnd","useCallback","handleAnimationStart","prevPoints","current","prevBaseLine","Animate","begin","duration","isActive","easing","from","to","_ref7","stepBaseLine","prevPointsDiffFactor","stepPoints","prevPointIndex","prev","interpolate","isNullish","isNan","id","RenderArea","_ref8","useRef","AreaWithState","PureComponent","constructor","super","this","uniqueId","render","_filterProps","top","left","layerClass","dotSize","GraphicalItemClipPath","ActivePoints","mainColor","itemDataKey","activeDot","defaultAreaProps","fillOpacity","Global","isSsr","AreaImpl","_useAppSelector","_resolveDefaultProps","resolveDefaultProps","everythingElse","useChartLayout","chartName","useChartName","useNeedsClip","useIsPanorama","useMemo","baseValue","useAppSelector","useOffset","getBaseValue","itemBaseValue","numericAxis","domain","scale","domainMax","domainMin","min","_ref9","hasStack","isHorizontalLayout","getValueByDataKey","isBreakPoint","getCateCoordinateOfLine","axis","ticks","Area","CartesianGraphicalItemContext","zAxisId","barSize","SetLegendPayload","legendPayload","SetTooltipEntrySettings","fn","args"],"sourceRoot":""}